# -*- coding: utf-8 -*-
"""
Created on Tue Apr 12 00:12:17 2016

@author: avandenbroucke

A bunch of support functions for operations we might frequently do for TSwap
"""

from ..ReadEchoFiles import ReadCSV
import numpy as np
import scipy

def genMap(epcanalysisfile, writetodisk=False):
    """ Function generates a matrix map of Fitparameters based on the *Analyzed_Overall_data* file as generated by EPC.
    Writes to csv file if writetodisk is set to True
    Will return p0map and p1map as np arrays.
    Expected updated: specify number of parameter maps to return """  
  
    data = ReadCSV.readCSV(epcanalysisfile, True)
    p0map = np.zeros([16,24])
    p1map = np.zeros([16,24])

    for k in range(0,len(data)):
        row = data[k]['WellRow']
        col = data[k]['WellColumn']
        p0map[row,col] = data[k]['Constant']
        p1map[row,col] = data[k]['C']
        
    if (writetodisk):   
        np.savetxt("FitParam0.csv", p0map, delimiter=",")
        np.savetxt("FitParam1.csv", p1map, delimiter=",")
    
    return p0map, p1map     
    
	
	
import os
import fnmatch 
import pandas as pd
import matplotlib.pyplot as plt

def GetCoupledLog(wdir='.'):
    printfilelist = []
    for root, dirs, files in os.walk(wdir):
        for k in fnmatch.filter(files, '*coupled_input.csv'):
            printfilelist.append(os.path.join(root,k))
    return printfilelist
    
def ProcessCoupledInputFileList(filelist = []):   
    #pd.read_csv() convertlist to dataframe
     # z = pd.read_csv(pall[0], header=8)
    #call specific rows and columns using df.iloc[9:257,df.columns.get_loc('250')].max()
    allwav = pd.DataFrame()
    for file in filelist:    
     amp = file.split('\\')[1].split('_')[0].replace('p','.')
     wav = pd.read_csv(file, header=8)
     allwav[amp] = wav['v']        
    return allwav
 

def ProcessCoupledInputFileListRFHealthCheck(filelist = []):   
    #pd.read_csv() convertlist to dataframe
     # z = pd.read_csv(pall[0], header=8)
    #call specific rows and columns using df.iloc[9:257,df.columns.get_loc('250')].max()
    allwav = pd.DataFrame()
    for file in filelist:    
     parts = file.split('_')   
     amp = parts[4].split('V')[0]
     i = parts[5].split('.')[0]
     CF = parts[3].split('MHz')[0]
     w = pd.read_csv(file, header=8, index_col=0)
     wav = w.T
     wav['amp'] = amp
     wav['N'] = i
     wav['CF'] = CF
     allwav = allwav.append(wav)        
    return allwav


def SelectCFAndN(dataframe, CF='12',N='1'):
    return dataframe[(dataframe['CF'] == '12' ) & ( dataframe['N'] == '1')]

def ProcessCoupledInputPlot(allwav, title='CoupledInputTBW.png',figtitle='Coupled_Input'):
     amplitudes = allwav.columns.tolist()     
     fig,ax = plt.subplots();
     ax.set_ylabel('Volt (V)', fontsize=20);
     fig.suptitle('TBW Coupled Input', fontsize=22);
     for amp in amplitudes: 
         ax.plot(allwav[amp])
     fig.savefig('TBWCoupledInput.png');
     return
	 
	 
def ProcessScatterCIPlot(allwav):
    data = allwav.max()
    xval = data.index
    xval = [float (f) for f in xval]
    yval = data.values
    yval = [float (f) for f in yval]
    plt.plot(xval,yval,'o')
    plt.ylabel('Coupled Input (V)');
    plt.xlabel('Ping Amplitude (Vpp)');
    plt.title('Coupled Input vs Ping Amplitude')
    return
    
	

def FindSplit(xval, yval, targetR2val = 0.999, verbose=False):
    for i in range(len(xval)-3, 3, -1):
#    for i in range(3, len(xval)-3):
        slope, intercept, r_value, p_value, std_err = scipy.stats.linregress(xval[0:i], yval[0:i])
        if (verbose):
            print(' npoints: ', i, ' r_value : ', r_value, ' slope: ', slope, ' intercept: ', intercept, ' x: ', xval[i] )
        if  ( r_value > targetR2val):
            return i-1
    return -1
    
def findSlopesAndTurnOver(xval, yval, split=6, TaborAttenuation=-21, CouplerdB=33.5):
    gaincor = np.power(10, (-TaborAttenuation+CouplerdB)/20)
    slope_h, intercept_h, r_value_h, p_value_h, std_err_h = scipy.stats.linregress(xval[0:split], yval[0:split])
    slope_l, intercept_l, r_value_l, p_value_l, std_err_l = scipy.stats.linregress(xval[split:], yval[split:])
    switchpoint =  ( intercept_l - intercept_h) / ( slope_h - slope_l)
    return slope_h*gaincor, slope_l*gaincor, switchpoint
	
 
 
def scratch():
     f = os.listdir()
     A = ProcessCoupledInputFileListRFHealthCheck(f)
     BB = A.set_index(['CF','amp','N'])
     cfs = BB.index.levels[0].tolist()
     amps = BB.index.levels[1].tolist()
#plotting time domain stuff:     
     rc = 0
     cc = 0  
     fig,ax = plt.subplots(ncols=2, nrows=5,figsize=(12,10));
     tit = 'TBW Coupled Input'
     fig.suptitle(tit, fontsize=22);
     for c in cfs:  
         ax[rc][cc].set_ylabel('Volt (V)', fontsize=20);   
         for a in amps: 
             ax[rc][cc].plot(BB.xs((c,a, '1'), level=('CF','amp', 'N')).iloc[0])
         if cc == 0 :   
             cc += 1 
         else :    
             cc = 0
             rc +=1
             
     CC = BB.T.max()        
     nn = CC.index.levels[2].tolist()
# plotting max amp vs input amp:             
     fig, ax = plt.subplots();
     for c in cfs:
         xx = np.asarray(amps,float)
         Y = []
         for n in nn :
             Y.append( CC.xs((c,n), level=('CF','N')).values)
         yy = pandas.DataFrame(Y).median().values    
         ax.plot(xx,yy,'o')
     
# plot max fourier transform:
     fig, ax = plt.subplots();
     for a in amps[:10]:
         y = []
         for c in cfs:
             aa, bb = SimpleTools.simpleFFT( np.asarray(BB.xs((c,a, '1'), level=('CF','amp', 'N')).iloc[0]).astype(float) ) ;
             m = np.max(bb[:300])
             y.append(m)
         ax.plot(np.asarray(cfs,float),y/max(y),'o')
         
